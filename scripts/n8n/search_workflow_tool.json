{
  "name": "My Sub-Workflow 1",
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "id": "c055762a-8fe7-4141-a639-df2372f30060",
      "typeVersion": 1.1,
      "name": "When Executed by Another Workflow",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "position": [
        128,
        352
      ]
    },
    {
      "parameters": {
        "jsCode": "function clampInt(n, min, max, def) {\n  n = Number.isInteger(n) ? n : def;\n  return Math.max(min, Math.min(max, n));\n}\n\nfunction toStringSafe(value) {\n  return (value ?? \"\").toString().trim();\n}\n\nfunction stripQuotes(input) {\n  return toStringSafe(input).replace(/[“”«»\"']/g, \"\").trim();\n}\n\nconst src = items[0]?.json?.output || {};\nconst plan = JSON.parse(JSON.stringify(src));\n\nplan.topK = clampInt(plan.topK, 1, 50, 5);\nplan.mode = plan.mode || (plan.semantic ? \"hybrid\" : \"lexical\");\nplan.semantic = plan.mode === \"hybrid\";\n\nlet queryText = \"\";\nif (toStringSafe(plan.phrase)) {\n  queryText = stripQuotes(plan.phrase);\n} else if (toStringSafe(plan.keywords)) {\n  queryText = toStringSafe(plan.keywords);\n} else {\n  queryText = \"notícies rellevants\";\n}\n\nif (!plan.return) plan.return = {};\nif (!plan.return.index) {\n  plan.return.index = plan.intent === \"search_chunks\" ? \"chunks\" : \"articles\";\n}\nif (!Array.isArray(plan.return.fields) || !plan.return.fields.length) {\n  plan.return.fields = plan.return.index === \"chunks\"\n    ? [\"url\", \"content\", \"chunk_ix\", \"published_at\", \"site\", \"lang\", \"author\"]\n    : [\"title\", \"url\", \"published_at\", \"site\", \"author\", \"description\"];\n}\n\nplan.filters = plan.filters || {};\nfor (const key of [\"site\", \"lang\", \"author\"]) {\n  if (Array.isArray(plan.filters[key]) && !plan.filters[key].length) {\n    delete plan.filters[key];\n  }\n}\n\nplan.sort = plan.sort || { by: \"published_at\", order: \"desc\" };\n\nconst semantic = !!plan.semantic;\n\nreturn [{\n  json: {\n    plan,\n    query_text: queryText,\n    fields: plan.return.fields,\n    topK: plan.topK,\n    semantic,\n    mode: plan.mode\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        416,
        352
      ],
      "id": "fb87c63c-da0b-459d-bf96-5ddb97516e6e",
      "name": "Prepare Plan"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "7ed71116-429e-4230-8f99-5e850da1f27d",
              "leftValue": "={{ $json.plan.semantic }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        624,
        352
      ],
      "id": "6912675a-5217-49ed-98ce-e923b5660047",
      "name": "If"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"text-embedding-3-small\",\n  \"input\": \"{{ $json.query_text }}\"\n}\n",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        976,
        -96
      ],
      "id": "d76e1328-f9d9-4d0c-a8a8-0003b6226aa1",
      "name": "OpenAI Embedding",
      "credentials": {
        "openAiApi": {
          "id": "sBtqsHWcpktkUaWf",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Construye un payload limpio para buildDSL:\nreturn [{  \n    ... $('Prepare Plan').first().json,    \n    embedding: $input.first().json.data[0].embedding\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -96
      ],
      "id": "444c1123-5267-4a71-a34b-3fedd3d3598f",
      "name": "Code in JavaScript"
    },
    {
      "parameters": {
        "jsCode": "const EXACT_FIELDS = {\n  site: \"site.keyword\",\n  author: \"author.keyword\",\n  lang: \"lang.keyword\"\n};\n\nfunction resolveField(field) {\n  return EXACT_FIELDS[field] || field;\n}\n\nfunction termFilter(field, values) {\n  if (Array.isArray(values) && values.length) {\n    return { terms: { [resolveField(field)]: values } };\n  }\n  return null;\n}\n\nfunction rangeFilter(field, gte, lte) {\n  const range = {};\n  if (gte) range.gte = gte;\n  if (lte) range.lte = lte;\n  return Object.keys(range).length ? { range: { [field]: range } } : null;\n}\n\nfunction makeFilters(filters) {\n  const must = [];\n  if (!filters) return must;\n  for (const clause of [\n    termFilter(\"site\", filters.site),\n    termFilter(\"lang\", filters.lang),\n    termFilter(\"author\", filters.author),\n    rangeFilter(\"published_at\", filters.date_from, filters.date_to)\n  ]) {\n    if (clause) must.push(clause);\n  }\n  return must;\n}\n\nfunction lexicalQueryArticles(plan, queryText, mustFilters) {\n  const should = [];\n  if (plan.phrase) {\n    should.push({ match_phrase: { title: queryText } });\n    should.push({ match_phrase: { description: queryText } });\n  }\n  if (plan.keywords || (!plan.phrase && queryText)) {\n    should.push({\n      multi_match: {\n        query: queryText,\n        fields: [\"search_text_short^3\", \"title^4\", \"description^2\", \"content\"],\n        type: \"best_fields\",\n        operator: \"and\"\n      }\n    });\n  }\n  return {\n    bool: {\n      must: mustFilters,\n      should,\n      minimum_should_match: should.length ? 1 : 0\n    }\n  };\n}\n\nfunction lexicalQueryChunks(plan, queryText, mustFilters) {\n  const should = [];\n  if (plan.phrase) {\n    should.push({ match_phrase: { content: queryText } });\n  }\n  if (plan.keywords || (!plan.phrase && queryText)) {\n    should.push({\n      multi_match: {\n        query: queryText,\n        fields: [\"content\"],\n        type: \"best_fields\",\n        operator: \"and\"\n      }\n    });\n  }\n  return {\n    bool: {\n      must: mustFilters,\n      should,\n      minimum_should_match: should.length ? 1 : 0\n    }\n  };\n}\n\nfunction joinUrl(base, path) {\n  const trimmedBase = base ? base.replace(/\\/+$/, \"\") : \"\";\n  const trimmedPath = path.replace(/^\\/+/, \"\");\n  return trimmedBase ? `${trimmedBase}/${trimmedPath}` : `/${trimmedPath}`;\n}\n\nconst input = items[0].json;\nconst plan = input.plan;\nconst fields = Array.isArray(input.fields) && input.fields.length ? input.fields : undefined;\nconst topK = input.topK || plan.topK || 5;\nconst filtersBool = makeFilters(plan.filters);\nconst sortBy = plan.sort?.by || \"published_at\";\nconst sortOrder = plan.sort?.order || \"desc\";\nconst bonsai = (input.bonsai && typeof input.bonsai === \"object\") ? input.bonsai : {};\nconst baseUrlCandidate = typeof input.baseUrl === \"string\" ? input.baseUrl : bonsai.baseUrl;\nconst baseUrl = typeof baseUrlCandidate === \"string\" ? baseUrlCandidate : \"\";\nconst indexArticles = input.indexArticles || \"articles-live\";\nconst indexChunks = input.indexChunks || \"chunks-live\";\nconst queryText = input.query_text || \"\";\n\nlet url = \"\";\nlet body = {};\nlet target = plan.return?.index === \"chunks\" ? \"chunks\" : \"articles\";\n\nif (plan.intent === \"latest_by_site\") {\n  const topHits = {\n    size: plan.topK || 5,\n    sort: [{ [sortBy]: { order: sortOrder, unmapped_type: \"date\" } }]\n  };\n  if (fields) topHits._source = fields;\n  body = {\n    size: 0,\n    query: { bool: { must: filtersBool } },\n    aggs: {\n      by_site: {\n        terms: { field: resolveField(\"site\"), size: 50 },\n        aggs: { latest: { top_hits: topHits } }\n      }\n    }\n  };\n  url = joinUrl(baseUrl, `${indexArticles}/_search`);\n  target = \"aggs\";\n} else if (plan.intent === \"search_articles\") {\n  if (plan.mode === \"lexical\") {\n    body = {\n      size: topK,\n      query: lexicalQueryArticles(plan, queryText, filtersBool),\n      sort: [{ [sortBy]: { order: sortOrder, unmapped_type: \"date\" } }]\n    };\n    if (fields) body._source = fields;\n    url = joinUrl(baseUrl, `${indexArticles}/_search`);\n    target = \"articles_lexical\";\n  } else {\n    if (!Array.isArray(input.embedding) || !input.embedding.length) {\n      throw new Error(\"Falta 'embedding' para búsqueda semántica (search_articles hybrid).\");\n    }\n    const k = Math.max(5 * topK, 200);\n    const numCandidates = Math.max(10 * topK, 500);\n    body = {\n      size: k,\n      _source: [\"url\", \"site\", \"author\", \"published_at\", \"chunk_ix\"],\n      query: {\n        knn: {\n          field: \"content_vec\",\n          query_vector: input.embedding,\n          k,\n          num_candidates: numCandidates,\n          filter: { bool: { must: filtersBool } }\n        }\n      },\n      sort: [{ [sortBy]: { order: sortOrder, unmapped_type: \"date\" } }]\n    };\n    url = joinUrl(baseUrl, `${indexChunks}/_search`);\n    target = \"articles_from_chunks\";\n  }\n} else if (plan.intent === \"search_chunks\") {\n  if (plan.mode === \"lexical\") {\n    body = {\n      size: topK,\n      query: lexicalQueryChunks(plan, queryText, filtersBool),\n      sort: [{ [sortBy]: { order: sortOrder, unmapped_type: \"date\" } }]\n    };\n    if (fields) body._source = fields;\n    url = joinUrl(baseUrl, `${indexChunks}/_search`);\n    target = \"chunks_lexical\";\n  } else {\n    if (!Array.isArray(input.embedding) || !input.embedding.length) {\n      throw new Error(\"Falta 'embedding' para búsqueda semántica (search_chunks hybrid).\");\n    }\n    const k = Math.max(5 * topK, 200);\n    const numCandidates = Math.max(10 * topK, 500);\n    body = {\n      size: topK,\n      _source: fields || [\"url\", \"content\", \"chunk_ix\", \"published_at\", \"site\", \"lang\", \"author\"],\n      query: {\n        knn: {\n          field: \"content_vec\",\n          query_vector: input.embedding,\n          k,\n          num_candidates: numCandidates,\n          filter: { bool: { must: filtersBool } }\n        }\n      },\n      sort: [{ [sortBy]: { order: sortOrder, unmapped_type: \"date\" } }]\n    };\n    url = joinUrl(baseUrl, `${indexChunks}/_search`);\n    target = \"chunks_knn\";\n  }\n} else if (plan.intent === \"summarize\") {\n  body = { size: 0, query: { match_none: {} } };\n  url = joinUrl(baseUrl, `${indexArticles}/_search`);\n  target = \"noop\";\n} else {\n  throw new Error(`Intent no soportado: ${plan.intent}`);\n}\n\nreturn [{ json: { url, body, intent: plan.intent, target } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1488,
        208
      ],
      "id": "f176a14e-3839-41dd-834b-ba6aad246104",
      "name": "BuildDLS"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://persualia-search-7928681425.eu-west-1.bonsaisearch.net{{ $json.url }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "elasticsearchApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1760,
        208
      ],
      "id": "83ef236e-4b3e-4f03-8c7a-4d60bb88dc67",
      "name": "HTTP Request",
      "credentials": {
        "httpBasicAuth": {
          "id": "Tq4P1aCmlN9w7q2P",
          "name": "PT-DatabaseManagerAuth"
        },
        "elasticsearchApi": {
          "id": "rIZ36okfX6XokWMB",
          "name": "Cat Religio Opensearch account"
        }
      }
    }
  ],
  "pinData": {
    "When Executed by Another Workflow": [
      {
        "json": {
          "output": {
            "intent": "latest_by_site",
            "topK": 5,
            "keywords": "església Catalunya",
            "semantic": false,
            "mode": "lexical",
            "filters": {
              "lang": [
                "ca"
              ]
            },
            "sort": {
              "by": "published_at",
              "order": "desc"
            },
            "return": {
              "index": "articles",
              "fields": [
                "title",
                "url",
                "published_at",
                "site",
                "author",
                "description"
              ]
            },
            "need_summary": false
          }
        }
      }
    ]
  },
  "connections": {
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Prepare Plan",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Plan": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "OpenAI Embedding",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "BuildDLS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Embedding": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "BuildDLS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BuildDLS": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "3aecbcbd-7575-464a-ab98-f8df7695bbf9",
  "meta": {
    "instanceId": "d9644988dffef6f6cab575748aeca294d9a27931b98dc5bb58f2a58200eb664c"
  },
  "id": "BynuIddOj2SVWxcY",
  "tags": []
}